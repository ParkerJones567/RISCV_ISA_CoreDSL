import "RISCVBase.core_desc"

InstructionSet XCoreVMem extends RISCVBase {
    instructions {
        // ?
        CV_LB_ri_inc {
            encoding: imm12[11:0] :: rs1[4:0] :: 3'b000 :: rd[4:0] :: 7'b0001011;
            assembly:"{name(rd)}, {imm12}({name(rs1)}!)";
            behavior: {
                unsigned<XLEN> load_address = X[rs1];
                signed<8> res = (signed<8>)MEM[load_address];
                if (rd != 0) X[rd] = (unsigned<XLEN>)res;
                X[rs1] += (signed)imm12;
            }
        }
        CV_LBU_ri_inc {
            encoding: imm12[11:0] :: rs1[4:0] :: 3'b100 :: rd[4:0] :: 7'b0001011;
            assembly:"{name(rd)}, {imm12}({name(rs1)}!)";
            behavior: {
                unsigned<XLEN> load_address = X[rs1];
                unsigned<8> res = (unsigned<8>)MEM[load_address];
                if (rd != 0) X[rd] = (unsigned<XLEN>)res;
                X[rs1] += (signed)imm12;
            }
        }
        CV_LH_ri_inc {
            encoding: imm12[11:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b0001011;
            assembly:"{name(rd)}, {imm12}({name(rs1)}!)";
            behavior: {
                unsigned<XLEN> load_address = X[rs1];
                signed<16> res = (signed<16>)MEM[load_address];
                if (rd != 0) X[rd] = (unsigned<XLEN>)res;
                X[rs1] += (signed)imm12;
            }
        }
        CV_LHU_ri_inc {
            encoding: imm12[11:0] :: rs1[4:0] :: 3'b101 :: rd[4:0] :: 7'b0001011;
            assembly:"{name(rd)}, {imm12}({name(rs1)}!)";
            behavior: {
                unsigned<XLEN> load_address = X[rs1];
                unsigned<16> res = (unsigned<16>)MEM[load_address];
                if (rd != 0) X[rd] = (unsigned<XLEN>)res;
                X[rs1] += (signed)imm12;
            }
        }
        CV_LW_ri_inc {
            encoding: imm12[11:0] :: rs1[4:0] :: 3'b010 :: rd[4:0] :: 7'b0001011;
            assembly:"{name(rd)}, {imm12}({name(rs1)}!)";
            behavior: {
                unsigned<XLEN> load_address = X[rs1];
                signed<32> res = (signed<32>)MEM[load_address];
                if (rd != 0) X[rd] = (unsigned<XLEN>)res;
                X[rs1] += (signed)imm12;
            }
        }
        CV_LB_rr_inc {
            encoding: 7'b0000100 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs2)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1];  // TODO: signed?
                signed<8> res = (signed<8>)MEM[load_address];
                if(rd != 0) X[rd] = (unsigned<XLEN>)res;
                X[rs1] += (signed)X[rs2];
            }
        }
        CV_LBU_rr_inc {
            encoding: 7'b0001100 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs2)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1];  // TODO: signed?
                unsigned<8> res = (unsigned<8>)MEM[load_address];
                if(rd != 0) X[rd] = (unsigned<XLEN>)res;
                X[rs1] += (signed)X[rs2];
            }
        }
        CV_LH_rr_inc {
            encoding: 7'b0000101 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs2)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1];  // TODO: signed?
                signed<16> res = (signed<16>)MEM[load_address];
                if(rd != 0) X[rd] = (unsigned<XLEN>)res;
                X[rs1] += (signed)X[rs2];
            }
        }
        CV_LHU_rr_inc {
            encoding: 7'b0001101 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs2)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1];  // TODO: signed?
                unsigned<16> res = (unsigned<16>)MEM[load_address];
                if(rd != 0) X[rd] = (unsigned<XLEN>)res;
                X[rs1] += (signed)X[rs2];
            }
        }
        CV_LW_rr_inc {
            encoding: 7'b0000010 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs2)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1];  // TODO: signed?
                signed<32> res = (signed<32>)MEM[load_address];
                if(rd != 0) X[rd] = (unsigned<XLEN>)res;
                X[rs1] += (signed)X[rs2];
            }
        }
        CV_LBU_rr {
            encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b0000011;
            assembly:"{name(rd)}, {name(rs2)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1] + X[rs2];  // TODO: signed?
                unsigned<8> res = (unsigned<8>)MEM[load_address];
                if(rd != 0) X[rd] = (unsigned<XLEN>)res;
            }
        }
        CV_LB_rr {
            encoding: 7'b0100000 :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b0000011;
            assembly:"{name(rd)}, {name(rs2)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1] + X[rs2];  // TODO: signed?
                signed<8> res = (signed<8>)MEM[load_address];
                if(rd != 0) X[rd] = (unsigned<XLEN>)res;
            }
        }
        CV_LH_rr {
            encoding: 7'b0001000 :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b0000011;
            assembly:"{name(rd)}, {name(rs2)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1] + X[rs2];  // TODO: signed?
                signed<16> res = (signed<16>)MEM[load_address];
                if(rd != 0) X[rd] = (unsigned<XLEN>)res;
            }
        }
        CV_LHU_rr {
            encoding: 7'b0101000 :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b0000011;
            assembly:"{name(rd)}, {name(rs2)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1] + X[rs2];  // TODO: signed?
                unsigned<16> res = (unsigned<16>)MEM[load_address];
                if(rd != 0) X[rd] = (unsigned<XLEN>)res;
            }
        }
        CV_LW_rr {
            encoding: 7'b0010000 :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b0000011;
            assembly:"{name(rd)}, {name(rs2)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> load_address = X[rs1] + X[rs2];  // TODO: signed?
                signed<32> res = (signed<32>)MEM[load_address];
                if(rd != 0) X[rd] = (unsigned<XLEN>)res;
            }
        }
        CV_SB_ri_inc {
            encoding: imm12[11:5] :: rs2[4:0] :: rs1[4:0] :: 3'b000 :: imm12[4:0] :: 7'b0101011;
            assembly:"{name(rs2)}, {imm12}({name(rs1)}!)";
            behavior: {
                unsigned<XLEN> store_address = X[rs1];
                MEM[store_address] = (signed<8>)X[rs2];
                X[rs1] += (signed)imm12;
            }
        }
        CV_SH_ri_inc {
            encoding: imm12[11:5] :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: imm12[4:0] :: 7'b0101011;
            assembly:"{name(rs2)}, {imm12}({name(rs1)}!)";
            behavior: {
                unsigned<XLEN> store_address = X[rs1];
                MEM[store_address] = (signed<16>)X[rs2];
                X[rs1] += (signed)imm12;
            }
        }
        CV_SW_ri_inc {
            encoding: imm12[11:5] :: rs2[4:0] :: rs1[4:0] :: 3'b010 :: imm12[4:0] :: 7'b0101011;
            assembly:"{name(rs2)}, {imm12}({name(rs1)}!)";
            behavior: {
                unsigned<XLEN> store_address = X[rs1];
                MEM[store_address] = (signed<32>)X[rs2];
                X[rs1] += (signed)imm12;
            }
        }
        CV_SB_rr_inc {
            encoding: 7'b0010000 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rs3[4:0] :: 7'b0101011;
            assembly:"{name(rs2)}, {name(rs3)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> store_address = X[rs1];  // TODO: signed?
								MEM[store_address] = (signed<8>)X[rs2];
                X[rs1] += (signed)X[rs3];
            }
        }
        CV_SH_rr_inc {
            encoding: 7'b0010001 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rs3[4:0] :: 7'b0101011;
            assembly:"{name(rs2)}, {name(rs3)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> store_address = X[rs1];  // TODO: signed?
								MEM[store_address] = (signed<16>)X[rs2];
                X[rs1] += (signed)X[rs3];
            }
        }
        CV_SW_rr_inc {
            encoding: 7'b0010010 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rs3[4:0] :: 7'b0101011;
            assembly:"{name(rs2)}, {name(rs3)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> store_address = X[rs1];  // TODO: signed?
								MEM[store_address] = (signed<32>)X[rs2];
                X[rs1] += (signed)X[rs3];
            }
        }
        CV_SB_rr {
            encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b100 :: rs3[4:0] :: 7'b0100011;
            assembly:"{name(rs2)}, {name(rs3)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> store_address = X[rs1] + X[rs3];  // TODO: signed?
								MEM[store_address] = (signed<8>)X[rs2];
            }
        }
        CV_SH_rr {
            encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b101 :: rs3[4:0] :: 7'b0100011;
            assembly:"{name(rs2)}, {name(rs3)}({name(rs1)})";
            behavior: {
                unsigned<XLEN> store_address = X[rs1] + X[rs3];  // TODO: signed?
								MEM[store_address] = (signed<16>)X[rs2];
            }
        }
        CV_SW_rr {
            encoding: 7'b0000000 :: rs2[4:0] :: rs1[4:0] :: 3'b110 :: rs3[4:0] :: 7'b0100011;
            assembly:"{name(rs2)}, {name(rs3)}({name(rs1)})";
            behavior: {
                signed<32> result = 0;
                unsigned<XLEN> store_address = X[rs1] + X[rs3];  // TODO: signed?
								MEM[store_address] = (signed<32>)X[rs2];
            }
        }
    }
}

InstructionSet XCoreVMac extends RISCVBase {
    instructions {
        // 32-Bit x 32-Bit Multiplication Operations (Signed)
        CV_MAC {
            encoding: 7'b1001000 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior: {
              // signed<65> result = (signed)X[rs1] * (signed)X[rs2] + (signed)X[rd];
              signed<64> result = (signed)X[rs1] * (signed)X[rs2] + (signed)X[rd];
              if(rd != 0) X[rd] = result[31:0];
            }
        }
        CV_MSU {
            encoding: 7'b1001001 :: rs2[4:0] :: rs1[4:0] :: 3'b011 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior: {
              // signed<65> result = (signed)X[rd] - (signed)X[rs1] * (signed)X[rs2] ;
              signed<64> result = (signed)X[rd] - (signed)X[rs1] * (signed)X[rs2] ;
              if(rd != 0) X[rd] = result[31:0];
            }
        }
        // 16-Bit x 16-Bit Multiplication
        CV_MULUN {
            encoding: 2'b00 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b101 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
              unsigned<32> result = ((unsigned)X[rs1][15:0] * (unsigned)X[rs2][15:0]) >> Is3;
              if(rd != 0) X[rd] = result[31:0];
            }
        }
        CV_MULHHUN {
            encoding: 2'b01 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b101 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
              unsigned<32> result = ((unsigned)X[rs1][31:16] * (unsigned)X[rs2][31:16]) >> Is3;
              if(rd != 0) X[rd] = result[31:0];
            }
        }
        CV_MULS {
            encoding: 2'b00 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b100 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
              signed<32> result = ((signed)X[rs1][15:0] * (signed)X[rs2][15:0]) >> Is3;
              if(rd != 0) X[rd] = result[31:0];
            }
        }
        CV_MULSN {
            encoding: 2'b00 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b100 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
              signed<32> result = ((signed)X[rs1][15:0] * (signed)X[rs2][15:0]) >> Is3;
              if(rd != 0) X[rd] = result[31:0];
            }
        }
        CV_MULHHSN {
            encoding: 2'b01 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b100 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
              signed<32> result = ((signed)X[rs1][31:16] * (signed)X[rs2][31:16]) >> Is3;
              if(rd != 0) X[rd] = result[31:0];
            }
        }
        CV_MULURN {
            encoding: 2'b10:: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 0b101 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
				signed<31> product = (unsigned)X[rs1][15:0] * (unsigned)X[rs2][15:0];
				unsigned<30> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				unsigned<32> sum = product + powerOf2;
				unsigned<32> rounded = sum >> Is3;

				X[rd] = rounded[31:0];
            }
        }
        CV_MULHHURN {
            encoding: 2'b11:: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 0b101 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
				signed<31> product = (unsigned)X[rs1][31:16] * (unsigned)X[rs2][31:16];
				unsigned<30> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				unsigned<32> sum = product + powerOf2;
				unsigned<32> rounded = sum >> Is3;

				X[rd] = rounded[31:0];
            }
        }
        CV_MULSRN {
            encoding: 2'b10:: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 0b100 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
				signed<31> product = (signed)X[rs1][15:0] * (signed)X[rs2][15:0];
				unsigned<30> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				signed<32> sum = product + powerOf2;
				signed<32> rounded = sum >> Is3;

				X[rd] = rounded[31:0];
            }
        }
        CV_MULHHSRN {
            encoding: 2'b11:: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 0b100 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
				signed<31> product = (signed)X[rs1][31:16] * (signed)X[rs2][31:16];
				unsigned<30> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				signed<32> sum = product + powerOf2;
				signed<32> rounded = sum >> Is3;

				X[rd] = rounded[31:0];
            }
        }
        // 16-Bit x 16-Bit Multiply-Accumulate
        CV_MACUN {
            encoding: 2'b00 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
              unsigned<32> result = ((unsigned)X[rs1][15:0] * (unsigned)X[rs2][15:0] + (unsigned)X[rd]) >> Is3;
              if(rd != 0) X[rd] = result[31:0];
            }
        }
        CV_MACHHUN {
            encoding: 2'b01 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b111 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
              unsigned<32> result = ((unsigned)X[rs1][31:16] * (unsigned)X[rs2][31:16] + (unsigned)X[rd]) >> Is3;
              if(rd != 0) X[rd] = result[31:0];
            }
        }
        CV_MACSN {
            encoding: 2'b10 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b1011011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
              signed<32> result = ((signed)X[rs1][15:0] * (signed)X[rs2][15:0] + (signed)X[rd]) >> Is3;
              if(rd != 0) X[rd] = result[31:0];
            }
        }
        CV_MACHHSN {
            encoding: 2'b11 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 3'b001 :: rd[4:0] :: 7'b1011011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
              signed<32> result = ((signed)X[rs1][31:16] * (signed)X[rs2][31:16] + (signed)X[rd]) >> Is3;
              if(rd != 0) X[rd] = result[31:0];
            }
        }
        CV_MACURN {
            encoding: 2'b10 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 0b110 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
				unsigned<30> product = (unsigned)(X[rs1][15:0]) * (unsigned)(X[rs2][15:0]);
				unsigned<30> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				unsigned<33> sum = product + (unsigned)X[rd] + powerOf2;
				unsigned<33> rounded = sum >> Is3;

				X[rd] = rounded[31:0];
            }
        }
        CV_MACHHURN {
            encoding: 2'b11 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 0b110 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
				unsigned<30> product = (unsigned)(X[rs1][31:16]) * (unsigned)(X[rs2][31:16]);
				unsigned<30> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				unsigned<33> sum = product + (unsigned)X[rd] + powerOf2;
				unsigned<33> rounded = sum >> Is3;

				X[rd] = rounded[31:0];
            }
        }
        CV_MACSRN {
            encoding: 2'b10 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 0b111 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
				signed<31> product = (signed)X[rs1][15:0] * (signed)X[rs2][15:0];
				unsigned<30> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				signed<32> sum = product + (signed)X[rd] + powerOf2;
				signed<32> rounded = sum >> Is3;

				X[rd] = rounded[31:0];
            }
        }
        CV_MACHHSRN {
            encoding: 2'b11 :: Is3[4:0] :: rs2[4:0] :: rs1[4:0] :: 0b111 :: rd[4:0] :: 7'b0101011;
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}, {Is3}";
            behavior: {
				signed<31> product = (signed)X[rs1][31:16] * (signed)X[rs2][31:16];
				unsigned<30> powerOf2 = 1 << (Is3-1);  // TODO: Is3 = max(Is3, 1)
				signed<32> sum = product + (signed)X[rd] + powerOf2;
				signed<32> rounded = sum >> Is3;

				X[rd] = rounded[31:0];
            }
        }
    }
}

InstructionSet XCoreVAlu extends RISCVBase {
    instructions {
        CV_MAX {
            encoding: 0b0101101 :: rs2[4:0] :: rs1[4:0] :: 0b011 :: rd[4:0] :: 0b0101011; // TODO
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                X[rd] = (signed)X[rs1] > (signed)X[rs2] ? X[rs1] : X[rs2];  // signed
            }
        }
        CV_MAXU {
            encoding: 0b0101110 :: rs2[4:0] :: rs1[4:0] :: 0b011 :: rd[4:0] :: 0b0101011; // TODO
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                X[rd] = (unsigned)X[rs1] > (unsigned)X[rs2] ? X[rs1] : X[rs2];  // unsigned
            }
        }
        CV_MIN {
            encoding: 0b0101011 :: rs2[4:0] :: rs1[4:0] :: 0b011 :: rd[4:0] :: 0b0101011; // TODO
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                X[rd] = (signed)X[rs1] < (signed)X[rs2] ? X[rs1] : X[rs2];  // signed
            }
        }
        CV_MINU {
            encoding: 0b0101100 :: rs2[4:0] :: rs1[4:0] :: 0b011 :: rd[4:0] :: 0b0101011; // TODO
            assembly:"{name(rd)}, {name(rs1)}, {name(rs2)}";
            behavior: {
                X[rd] = (unsigned)X[rs1] < (unsigned)X[rs2] ? X[rs1] : X[rs2];  // unsigned
            }
        }
    }
}

InstructionSet XCoreVHwlp extends RISCVBase {

}

InstructionSet XCoreVSimd extends RISCVBase {

}

InstructionSet XCoreVBranchImmediate extends RISCVBase {
    instructions {
        CV_BEQIMM [[no_cont]] [[cond]] {
            encoding: imm[12:12] ::imm[10:5] :: simm5[4:0] :: rs1[4:0] :: 3'b110 :: imm[4:1] :: imm[11:11] :: 7'b0001011;
            assembly:"{name(rs1)}, {simm5:#0x}, {imm:#0x}";
            behavior: {
                if (X[rs1 % RFS] == (signed)simm5) {
                    if(imm % INSTR_ALIGNMENT) {
                        raise(0, 0);
                    } else {
                        PC = PC + (signed)imm;
                    }
                }
            }
        }
        CV_BNEIMM [[no_cont]] [[cond]] {
            encoding: imm[12:12] ::imm[10:5] :: simm5[4:0] :: rs1[4:0] :: 3'b111 :: imm[4:1] :: imm[11:11] :: 7'b0001011;
            assembly:"{name(rs1)}, {simm5:#0x}, {imm:#0x}";
            // operands: signed<5> simm5, signed<13> imm, unsigned<5> rs1;
            // constraints: { field in [1, 2, 4, 8] && imm % INSTR_ALIGNMENT == 0; }
            behavior: {
                if (X[rs1 % RFS] != (signed)simm5) {
                    if(imm % INSTR_ALIGNMENT) {
                        raise(0, 0);
                    } else {
                        PC = PC + (signed)imm;
                    }
                }
            }
        }
    }
}


InstructionSet XCoreV extends XCoreVMac, XCoreVMem, XCoreVBranchImmediate, XCoreVAlu. XCoreVSimd, XCoreVHwlp {
    architectural_state {
        unsigned<1> A = 1;  // TODO: Remove
    }
}
